#!/usr/bin/env bash

# update-models - Fetch available Copilot models, test each one, and update files.
#
# Environment variables:
#   GITHUB_TOKEN - GitHub PAT with copilot scope (required)
#
# Usage:
#   ./update-models              # Update files in place
#   ./update-models --dry-run    # Show what would change without modifying files

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
README_FILE="$SCRIPT_DIR/README.md"
CONFIG_FILE="$SCRIPT_DIR/config.yaml"
TODAY=$(date +%Y-%m-%d)

MODELS_API_URL="https://api.githubcopilot.com/models"
CHAT_API_URL="https://api.githubcopilot.com/chat/completions"
RESPONSES_API_URL="https://api.githubcopilot.com/responses"

DRY_RUN=false
if [[ "$1" == "--dry-run" ]]; then
  DRY_RUN=true
fi

# Check for required tools
for cmd in jq curl; do
  if ! command -v $cmd &> /dev/null; then
    echo "Error: $cmd is required but not installed"
    exit 1
  fi
done

# Check for GITHUB_TOKEN
if [[ -z "$GITHUB_TOKEN" ]]; then
  echo "Error: GITHUB_TOKEN is not set"
  echo "Set it to a GitHub PAT with the 'copilot' scope"
  exit 1
fi

# Common headers for Copilot API
CURL_HEADERS=(
  -H "Authorization: Bearer $GITHUB_TOKEN"
  -H "Editor-Version: vscode/1.95.0"
  -H "Editor-Plugin-Version: copilot-chat/0.22.4"
  -H "Copilot-Integration-Id: vscode-chat"
)

echo "Fetching models from GitHub Copilot API..."

# Fetch models from API
RESPONSE=$(curl -s -w "\n%{http_code}" "${CURL_HEADERS[@]}" "$MODELS_API_URL")
HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
BODY=$(echo "$RESPONSE" | sed '$d')

if [[ "$HTTP_CODE" != "200" ]]; then
  echo "Error: API request failed with status $HTTP_CODE"
  echo "$BODY"
  exit 1
fi

# Filter and extract models
# - model_picker_enabled == true
# - name does not contain "Internal Only"
# - Sort by id for consistency
MODELS_JSON=$(echo "$BODY" | jq -c '
  [.data[]
   | select(.model_picker_enabled == true)
   | select(.name | contains("Internal Only") | not)
  ]
  | sort_by(.id)
')

MODEL_COUNT=$(echo "$MODELS_JSON" | jq 'length')
echo "Found $MODEL_COUNT available models"
echo

# Test a model and return 0 for success, 1 for failure
test_model() {
  local model_id="$1"
  local response
  local http_code
  local body
  local content

  # Use responses API for GPT-5 family, chat completions for others
  if [[ "$model_id" == gpt-5* ]]; then
    response=$(curl -s -w "\n%{http_code}" \
      "${CURL_HEADERS[@]}" \
      -H "Content-Type: application/json" \
      --max-time 60 \
      -d "{\"model\": \"$model_id\", \"input\": [{\"role\": \"user\", \"content\": \"Say hello in one word.\"}], \"reasoning\": {\"effort\": \"low\"}}" \
      "$RESPONSES_API_URL" 2>/dev/null)
  else
    response=$(curl -s -w "\n%{http_code}" \
      "${CURL_HEADERS[@]}" \
      -H "Content-Type: application/json" \
      --max-time 60 \
      -d "{\"model\": \"$model_id\", \"messages\": [{\"role\": \"user\", \"content\": \"Say hello in one word.\"}]}" \
      "$CHAT_API_URL" 2>/dev/null)
  fi

  http_code=$(echo "$response" | tail -n1)
  body=$(echo "$response" | sed '$d')

  if [[ "$http_code" != "200" ]]; then
    echo "FAIL - HTTP $http_code"
    return 1
  fi

  # Extract content based on response format
  if [[ "$model_id" == gpt-5* ]]; then
    content=$(echo "$body" | jq -r '.output[]? | select(.type == "message") | .content[]? | select(.type == "output_text") | .text' 2>/dev/null | head -c 50)
  else
    content=$(echo "$body" | jq -r '.choices[0].message.content // empty' 2>/dev/null | head -c 50)
  fi

  if [[ -n "$content" ]]; then
    echo "PASS"
    return 0
  else
    echo "FAIL - No content in response"
    return 1
  fi
}

# Test each model
echo "Testing models..."
echo "------------------------------------------------------------"

WORKING_MODELS=()
FAILED_MODELS=()

while IFS= read -r model_id; do
  printf "Testing %s... " "$model_id"
  if test_model "$model_id"; then
    WORKING_MODELS+=("$model_id")
  else
    FAILED_MODELS+=("$model_id")
  fi
done < <(echo "$MODELS_JSON" | jq -r '.[].id')

echo "------------------------------------------------------------"
echo

# Summary
echo "Results: ${#WORKING_MODELS[@]} working, ${#FAILED_MODELS[@]} failed"
echo

if [[ ${#FAILED_MODELS[@]} -gt 0 ]]; then
  echo "Failed models:"
  for model_id in "${FAILED_MODELS[@]}"; do
    echo "  - $model_id"
  done
  echo
fi

if [[ ${#WORKING_MODELS[@]} -eq 0 ]]; then
  echo "Error: No working models found!"
  exit 1
fi

# Generate markdown table for README (only include working models)
TABLE_HEADER="| Model | Vendor | Category |"
TABLE_SEP="| --- | --- | --- |"
TABLE_ROWS=""
for model_id in "${WORKING_MODELS[@]}"; do
  vendor=$(echo "$MODELS_JSON" | jq -r ".[] | select(.id == \"$model_id\") | .vendor")
  category=$(echo "$MODELS_JSON" | jq -r ".[] | select(.id == \"$model_id\") | .model_picker_category // \"â€”\"")
  TABLE_ROWS+="| $model_id | $vendor | $category |"$'\n'
done
TABLE_ROWS=${TABLE_ROWS%$'\n'}  # Remove trailing newline

# Generate model_group_alias entries for config.yaml (only supported models, identity mappings)
CONFIG_ALIASES=""
for model_id in "${WORKING_MODELS[@]}"; do
  CONFIG_ALIASES+="    \"$model_id\": \"$model_id\""$'\n'
done
CONFIG_ALIASES=${CONFIG_ALIASES%$'\n'}  # Remove trailing newline

if $DRY_RUN; then
  echo "=== DRY RUN - No files will be modified ==="
  echo
  echo "--- Table for README.md ---"
  echo "$TABLE_HEADER"
  echo "$TABLE_SEP"
  echo "$TABLE_ROWS"
  echo
  echo "--- Supported models for config.yaml ---"
  echo "$CONFIG_ALIASES"
  echo
  echo "--- Date: $TODAY ---"
  exit 0
fi

# Update README.md
echo "Updating $README_FILE..."

TEMP_FILE=$(mktemp)
IN_TABLE=false
TABLE_WRITTEN=false

while IFS= read -r line || [[ -n "$line" ]]; do
  # Update the date line
  if [[ "$line" == "Last updated:"* ]]; then
    printf '%s\n' "Last updated: $TODAY" >> "$TEMP_FILE"
  # Start of table (header row)
  elif [[ "$line" == "| Model |"* ]]; then
    IN_TABLE=true
    if ! $TABLE_WRITTEN; then
      printf '%s\n' "$TABLE_HEADER" >> "$TEMP_FILE"
      printf '%s\n' "$TABLE_SEP" >> "$TEMP_FILE"
      printf '%s\n' "$TABLE_ROWS" >> "$TEMP_FILE"
      TABLE_WRITTEN=true
    fi
  # Table separator or data rows (starts with |)
  elif $IN_TABLE && [[ "$line" == "|"* ]]; then
    continue
  # End of table (non-table line)
  elif $IN_TABLE && [[ "$line" != "|"* ]]; then
    IN_TABLE=false
    printf '%s\n' "$line" >> "$TEMP_FILE"
  # Regular line
  else
    printf '%s\n' "$line" >> "$TEMP_FILE"
  fi
done < "$README_FILE"

mv "$TEMP_FILE" "$README_FILE"

# Update config.yaml
# Strategy: Replace lines between "# Supported models" comment and "# Gemini CLI aliases" comment
echo "Updating $CONFIG_FILE..."

TEMP_FILE=$(mktemp)
IN_SUPPORTED_MODELS=false
SUPPORTED_MODELS_WRITTEN=false

while IFS= read -r line || [[ -n "$line" ]]; do
  # Start of supported models section
  if [[ "$line" == *"# Supported models"* ]]; then
    IN_SUPPORTED_MODELS=true
    printf '%s\n' "$line" >> "$TEMP_FILE"
    if ! $SUPPORTED_MODELS_WRITTEN; then
      printf '%s\n' "$CONFIG_ALIASES" >> "$TEMP_FILE"
      SUPPORTED_MODELS_WRITTEN=true
    fi
  # End of supported models section (start of Gemini CLI aliases or other section)
  elif $IN_SUPPORTED_MODELS && [[ "$line" == *"# Gemini CLI aliases"* ]]; then
    IN_SUPPORTED_MODELS=false
    printf '%s\n' "$line" >> "$TEMP_FILE"
  # Inside supported models section - skip old entries (already written new ones)
  elif $IN_SUPPORTED_MODELS && [[ "$line" =~ ^[[:space:]]*\" ]]; then
    continue
  # Regular line
  else
    printf '%s\n' "$line" >> "$TEMP_FILE"
  fi
done < "$CONFIG_FILE"

mv "$TEMP_FILE" "$CONFIG_FILE"

echo
echo "Done! Updated models list to $TODAY"
echo
echo "Working models (${#WORKING_MODELS[@]}):"
for model_id in "${WORKING_MODELS[@]}"; do
  echo "  $model_id"
done
