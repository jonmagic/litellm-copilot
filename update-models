#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.10"
# dependencies = [
#     "requests",
#     "litellm",
# ]
# ///
"""
update-models - Fetch available Copilot models, test each with litellm, and update files.

Environment variables:
  GITHUB_TOKEN - GitHub PAT with copilot scope (required)

Usage:
  ./update-models              # Update files in place
  ./update-models --dry-run    # Show what would change without modifying files
"""

import argparse
import os
import re
import sys
from datetime import date

import requests
from litellm import completion, responses


API_URL = "https://api.githubcopilot.com/models"
HEADERS = {
    "Editor-Version": "vscode/1.95.0",
    "Editor-Plugin-Version": "copilot-chat/0.22.4",
    "Copilot-Integration-Id": "vscode-chat",
}
TEST_PROMPT = "Say hello in one word."


def fetch_models(token: str) -> list[dict]:
    """Fetch available models from GitHub Copilot API."""
    headers = {**HEADERS, "Authorization": f"Bearer {token}"}
    resp = requests.get(API_URL, headers=headers, timeout=30)
    resp.raise_for_status()

    data = resp.json().get("data", [])

    # Filter: model_picker_enabled == true and not "Internal Only"
    models = [
        m
        for m in data
        if m.get("model_picker_enabled") is True
        and "Internal Only" not in m.get("name", "")
    ]

    # Sort by id for consistency
    return sorted(models, key=lambda m: m.get("id", ""))


def test_model(model_id: str, token: str) -> tuple[bool, str]:
    """
    Test a model by making a simple completion request.

    Returns (success, message) tuple.
    """
    full_model = f"github_copilot/{model_id}"
    headers = {**HEADERS}

    try:
        # Use responses API for GPT-5 family (reasoning-capable)
        if model_id.startswith("gpt-5"):
            resp = responses(
                model=full_model,
                input=[{"role": "user", "content": TEST_PROMPT}],
                headers=headers,
                reasoning_effort="low",
                request_timeout=30,
                max_retries=0,
            )
            # Extract content from responses API format
            content = None
            if getattr(resp, "output", None):
                for o in resp.output:
                    if getattr(o, "content", None):
                        for item in o.content:
                            text_val = getattr(item, "text", None)
                            if text_val:
                                content = text_val
                                break
                    if content:
                        break
            if not content and getattr(resp, "output_text", None):
                content = resp.output_text
        else:
            resp = completion(
                model=full_model,
                messages=[{"role": "user", "content": TEST_PROMPT}],
                headers=headers,
                request_timeout=30,
                max_retries=0,
            )
            content = resp.choices[0].message.content

        if content:
            return True, f"OK: {content[:50]}..."
        return False, "No content in response"

    except Exception as e:
        return False, str(e)[:100]


def generate_models_array(model_ids: list[str]) -> str:
    """Generate the MODELS=(...) array for the litellm-copilot script."""
    lines = ["MODELS=("]
    for model_id in model_ids:
        lines.append(f'  "{model_id}"')
    lines.append(")")
    return "\n".join(lines)


def generate_readme_table(models: list[dict]) -> str:
    """Generate the markdown table for README.md."""
    lines = [
        "| Model | Vendor | Category |",
        "| --- | --- | --- |",
    ]
    for m in models:
        model_id = m.get("id", "")
        vendor = m.get("vendor", "")
        category = m.get("model_picker_category", "â€”")
        lines.append(f"| {model_id} | {vendor} | {category} |")
    return "\n".join(lines)


def update_litellm_script(script_path: str, models_array: str, today: str) -> str:
    """Update the litellm-copilot script with new models. Returns new content."""
    with open(script_path) as f:
        content = f.read()

    # Update the date line
    content = re.sub(
        r"^# Model list last updated:.*$",
        f"# Model list last updated: {today}",
        content,
        flags=re.MULTILINE,
    )

    # Replace MODELS=(...) block
    content = re.sub(
        r"^MODELS=\([\s\S]*?^\)",
        models_array,
        content,
        flags=re.MULTILINE,
    )

    return content


def update_readme(readme_path: str, table: str, today: str) -> str:
    """Update the README.md with new models table. Returns new content."""
    with open(readme_path) as f:
        content = f.read()

    # Update the date line
    content = re.sub(
        r"^Last updated:.*$",
        f"Last updated: {today}",
        content,
        flags=re.MULTILINE,
    )

    # Replace the table (from "| Model |" through the last table row)
    content = re.sub(
        r"^\| Model \|.*?(?=\n\n|\n[^|]|\Z)",
        table,
        content,
        flags=re.MULTILINE | re.DOTALL,
    )

    return content


def main():
    parser = argparse.ArgumentParser(
        description="Fetch and test GitHub Copilot models, update litellm-copilot files."
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Show what would change without modifying files",
    )
    args = parser.parse_args()

    # Check for GITHUB_TOKEN
    token = os.environ.get("GITHUB_TOKEN")
    if not token:
        print("Error: GITHUB_TOKEN is not set")
        print("Set it to a GitHub PAT with the 'copilot' scope")
        sys.exit(1)

    script_dir = os.path.dirname(os.path.abspath(__file__))
    litellm_script = os.path.join(script_dir, "litellm-copilot")
    readme_file = os.path.join(script_dir, "README.md")
    today = date.today().isoformat()

    # Fetch models from API
    print("Fetching models from GitHub Copilot API...")
    try:
        all_models = fetch_models(token)
    except requests.RequestException as e:
        print(f"Error fetching models: {e}")
        sys.exit(1)

    print(f"Found {len(all_models)} available models")
    print()

    # Test each model
    print("Testing models with litellm...")
    print("-" * 60)

    working_models = []
    failed_models = []

    for model in all_models:
        model_id = model.get("id", "")
        print(f"Testing {model_id}...", end=" ", flush=True)

        success, message = test_model(model_id, token)

        if success:
            print(f"PASS")
            working_models.append(model)
        else:
            print(f"FAIL - {message}")
            failed_models.append((model_id, message))

    print("-" * 60)
    print()

    # Summary
    print(f"Results: {len(working_models)} working, {len(failed_models)} failed")
    print()

    if failed_models:
        print("Failed models:")
        for model_id, reason in failed_models:
            print(f"  - {model_id}: {reason}")
        print()

    if not working_models:
        print("Error: No working models found!")
        sys.exit(1)

    working_ids = [m.get("id", "") for m in working_models]

    # Generate updates
    models_array = generate_models_array(working_ids)
    readme_table = generate_readme_table(working_models)

    if args.dry_run:
        print("=== DRY RUN - No files will be modified ===")
        print()
        print("--- MODELS array for litellm-copilot ---")
        print(models_array)
        print()
        print("--- Table for README.md ---")
        print(readme_table)
        print()
        print(f"--- Date: {today} ---")
        return

    # Update files
    print(f"Updating {litellm_script}...")
    new_script = update_litellm_script(litellm_script, models_array, today)
    with open(litellm_script, "w") as f:
        f.write(new_script)

    print(f"Updating {readme_file}...")
    new_readme = update_readme(readme_file, readme_table, today)
    with open(readme_file, "w") as f:
        f.write(new_readme)

    print()
    print(f"Done! Updated models list to {today}")
    print()
    print(f"Working models ({len(working_ids)}):")
    for model_id in working_ids:
        print(f"  {model_id}")


if __name__ == "__main__":
    main()
